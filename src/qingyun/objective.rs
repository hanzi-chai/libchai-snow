use crate::qingyun::{
    context::冰雪清韵上下文, encoder::冰雪清韵编码器, 元素安排, 冰雪清韵决策, 冰雪清韵决策变化,
    冰雪清韵决策空间, 冰雪清韵编码信息, 所有汉字数, 最大码长, 进制, 音节信息, 频序, 频率,
};
use chai::{objectives::目标函数, 元素, 棱镜, 键位分布信息};
use rustc_hash::FxHashMap;
use serde::Serialize;
use std::{fmt::Display, iter::zip};

const 分级数: usize = 10;
const 分级大小: [频序; 分级数] = [
    500,
    1000,
    1500,
    2000,
    2500,
    3000,
    4000,
    5000,
    6000,
    频序::MAX,
];

#[derive(Debug, Clone, Serialize)]
pub struct 冰雪清韵指标 {
    pub 字根组数: usize,
    pub 字根数: usize,
    pub 拆分难度: f32,
    pub 韵母难度: f32,
    pub 简体分级选重数: [频序; 分级数],
    pub 简体选重率: 频率,
    pub 简体稳健选重率: 频率,
    pub 繁体分级选重数: [频序; 分级数],
    pub 繁体选重率: 频率,
    pub 繁体稳健选重率: 频率,
    pub 通打选重数: 频序,
    pub 通打平方选重数: 频序,
    pub 通打最大选重数: u8,
    pub 通打选重率: 频率,
    // 简码指标仅限于简体
    pub 组合当量: 频率,
    pub 稳健组合当量: 频率,
    pub 形码分布: Vec<频率>,
    pub 韵母分布: Vec<频率>,
    pub 形码分布偏差: 频率,
    pub 音码分布偏差: 频率,
    pub 码长: 频率,
    pub 音节熵: 频率,
    pub 双拼熵: 频率,
    pub 音码组合当量: 频率,
    pub 键转数字: FxHashMap<char, u64>,
}

const 键盘布局: [[char; 10]; 4] = [
    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';'],
    ['z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/'],
    ['_', '\'', '-', '=', '[', ']', '\\', '`', ' ', ' '],
];

impl Display for 冰雪清韵指标 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "字根组数：{}；字根数：{}；拆分难度：{:.2}；韵母难度：{:.2}；音节熵：{:.2}；双拼熵：{:.2}\n",
            self.字根组数, self.字根数, self.拆分难度, self.韵母难度, self.音节熵, self.双拼熵
        )?;
        write!(
            f,
            "简体选重数：{}；简体选重率：{:.0}μ；简体稳健选重率：{:.0}μ\n",
            self.简体分级选重数.iter().sum::<频序>(),
            self.简体选重率 * 1e6,
            self.简体稳健选重率 * 1e6,
        )?;
        write!(f, "简体选重分布：")?;
        for (分级, 大小) in 分级大小.iter().enumerate() {
            if 大小 != &频序::MAX {
                write!(f, "{} / {}；", self.简体分级选重数[分级], 大小)?;
            } else {
                write!(f, "{} / 其他；\n", self.简体分级选重数[分级])?;
            }
        }
        write!(
            f,
            "繁体选重数：{}；繁体选重率：{:.0}μ；繁体稳健选重率：{:.0}μ\n",
            self.繁体分级选重数.iter().sum::<频序>(),
            self.繁体选重率 * 1e6,
            self.繁体稳健选重率 * 1e6,
        )?;
        write!(f, "繁体选重分布：")?;
        for (分级, 大小) in 分级大小.iter().enumerate() {
            if 大小 != &频序::MAX {
                write!(f, "{} / {}；", self.繁体分级选重数[分级], 大小)?;
            } else {
                write!(f, "{} / 其他；\n", self.繁体分级选重数[分级])?;
            }
        }
        write!(
            f,
            "通打选重数：{}；通打选重率：{:.0}μ；通打最大选重数：{}；通打平方选重数：{}\n",
            self.通打选重数,
            self.通打选重率 * 1e6,
            self.通打最大选重数,
            self.通打平方选重数
        )?;
        write!(
            f,
            "码长：{:.4}；形码当量：{:.2}%；形码稳健当量：{:.2}%；音码当量：{:.2}%；形码分布偏差：{:.2}%；音码分布偏差：{:.2}%；形码分布：",
            self.码长,
            self.组合当量 * 100.0,
            self.稳健组合当量 * 100.0,
            self.音码组合当量 * 100.0,
            self.形码分布偏差 * 100.0,
            self.音码分布偏差 * 100.0
        )?;
        for 分布 in [&self.形码分布, &self.韵母分布] {
            for 行 in 键盘布局.iter() {
                if 行.iter().any(|x| self.键转数字.contains_key(x)) {
                    f.write_str("\n")?;
                    let mut buffer = vec![];
                    for 键 in 行 {
                        if let Some(数字) = self.键转数字.get(键) {
                            let 频率 = 分布[*数字 as usize];
                            buffer.push(format!("{} {:5.2}%", 键, 频率 * 100.0));
                        }
                    }
                    f.write_str(&buffer.join(" | "))?;
                }
            }
        }
        f.write_str("\n")
    }
}

pub struct 冰雪清韵目标函数 {
    pub 编码器: 冰雪清韵编码器,
    pub 编码结果: Vec<冰雪清韵编码信息>,
    pub 拆分序列: Vec<[元素; 4]>,
    pub 音码空间: Vec<f32>,
    pub 当量信息: Vec<频率>,
    pub 键位分布信息: 键位分布信息,
    pub 棱镜: 棱镜,
    pub 决策空间: 冰雪清韵决策空间,
    pub 拼音: Vec<音节信息>,
    pub 音节熵: f32,
}

impl 冰雪清韵目标函数 {
    pub fn 新建(上下文: &冰雪清韵上下文, 编码器: 冰雪清韵编码器) -> Self {
        let 当量信息 = 上下文
            .棱镜
            .预处理当量信息(&上下文.原始当量信息, 进制.pow(最大码长 as u32) as usize)
            .iter()
            .map(|&x| x as 频率)
            .collect();
        let 键位分布信息 = 上下文.棱镜.预处理键位分布信息(&上下文.原始键位分布信息);
        let 拆分序列 = vec![<[元素; 4]>::default(); 上下文.固定拆分.len()];
        let 编码结果: Vec<_> = 上下文
            .固定拆分
            .iter()
            .map(|x| 冰雪清韵编码信息 {
                简体: x.gb2312,
                繁体: x.国字常用 || x.陆标,
                简体频率: x.简体频率,
                简体指数频率: ((x.简体频序 as 频率).min(6000.0) / -1500.0).exp(),
                简体频序: x.简体频序,
                繁体频率: x.繁体频率,
                繁体指数频率: ((x.繁体频序 as 频率).min(6000.0) / -1000.0).exp(),
                繁体频序: x.繁体频序,
                通打频率: x.通打频率,
                全码: Default::default(),
                简体简码: Default::default(),
                简体选重: 0,
                繁体选重: 0,
                通打选重: 0,
                完成出简: false,
            })
            .collect();
        Self {
            编码器,
            编码结果,
            拆分序列,
            当量信息,
            键位分布信息,
            棱镜: 上下文.棱镜.clone(),
            决策空间: 上下文.决策空间.clone(),
            拼音: 上下文.拼音.clone(),
            音节熵: Self::计算音节熵(&上下文.拼音),
            音码空间: vec![0.0; (进制 * 进制) as usize],
        }
    }

    pub fn 计算音节熵(拼音: &[音节信息]) -> f32 {
        let mut 熵 = 0.0;
        for 音节 in 拼音 {
            if 音节.频率 > 0.0 {
                熵 -= 音节.频率 * 音节.频率.log2();
            }
        }
        熵
    }

    pub fn 计算音码指标(
        &self, 音码结果: &Vec<频率>
    ) -> (f32, f32, Vec<频率>, Vec<频率>) {
        let mut 双拼熵 = 0.0;
        let mut 音码当量 = 0.0;
        let mut 声母用指 = vec![0.0; 进制 as usize];
        let mut 韵母用指 = vec![0.0; 进制 as usize];
        for (编码, 频率) in 音码结果.iter().enumerate() {
            if *频率 > 0.0 {
                双拼熵 -= 频率 * 频率.log2();
                let 当量 = self.当量信息[编码];
                音码当量 += 频率 * 当量;
                let 声母 = 编码 % 进制 as usize;
                let 韵母 = 编码 / 进制 as usize;
                声母用指[声母] += 频率;
                韵母用指[韵母] += 频率;
            }
        }
        (双拼熵, 音码当量, 声母用指, 韵母用指)
    }

    pub fn 打分(&self, 决策: &冰雪清韵决策) -> f32 {
        let mut 总分 = 0.0;
        for 字根 in &self.决策空间.字根 {
            let 安排 = 决策.元素[*字根];
            let 安排列表 = &self.决策空间.元素[*字根];
            let mut 分值 = 0.0;
            for 条件安排 in 安排列表 {
                if 条件安排.安排 == 安排 {
                    分值 = 条件安排.打分 as f32;
                    break;
                }
            }
            总分 += 分值;
        }
        总分
    }

    pub fn 韵母打分(&self, 决策: &冰雪清韵决策) -> f32 {
        let mut 总分 = 0.0;
        for 韵母 in &self.决策空间.韵母 {
            let 安排 = 决策.元素[*韵母];
            let 安排列表 = &self.决策空间.元素[*韵母];
            let mut 分值 = 0.0;
            for 条件安排 in 安排列表 {
                if 条件安排.安排 == 安排 {
                    分值 = 条件安排.打分 as f32;
                    break;
                }
            }
            总分 += 分值;
        }
        总分
    }

    pub fn calculate(
        &self, 解: &冰雪清韵决策, 音码结果: &Vec<频率>
    ) -> (冰雪清韵指标, f32) {
        let 长度分界点 = [0, 1, 2, 3, 4].map(|x| 进制.pow(x));
        let mut 简体分级选重数 = [0; 分级数];
        let mut 简体总稳健频率 = 0.0;
        let mut 简体稳健选重频率 = 0.0;
        let mut 简体选重率 = 0.0;
        let mut 繁体分级选重数 = [0; 分级数];
        let mut 繁体总稳健频率 = 0.0;
        let mut 繁体稳健选重频率 = 0.0;
        let mut 繁体选重率 = 0.0;
        let mut 通打选重率 = 0.0;
        let mut 通打选重数 = 0;
        let mut 通打平方选重数 = 0;
        let mut 通打最大选重数 = 0;
        let mut 总组合当量 = 0.0;
        let mut 总稳健组合数 = 0.0;
        let mut 总稳健组合当量 = 0.0;
        let mut 形码分布 = vec![0.0; 进制 as usize];
        let mut 码长 = 0.0;
        for 编码信息 in &self.编码结果 {
            if 编码信息.通打选重 > 0 {
                通打选重率 += 编码信息.通打频率;
                通打选重数 += 1;
                通打平方选重数 += (2 * 编码信息.通打选重 - 1) as 频序;
                if 编码信息.通打选重 > 通打最大选重数 {
                    通打最大选重数 = 编码信息.通打选重;
                }
            }
            if 编码信息.简体 {
                简体总稳健频率 += 编码信息.简体指数频率;
                if 编码信息.简体选重 > 0 {
                    简体选重率 += 编码信息.简体频率;
                    简体稳健选重频率 += 编码信息.简体指数频率;
                    let 分级 = 分级大小
                        .iter()
                        .position(|&x| 编码信息.简体频序 < x)
                        .unwrap();
                    简体分级选重数[分级] += 1;
                }
                if 编码信息.简体频序 < 3000 {
                    let 简码 = 编码信息.简体简码;
                    let 编码长度 = 长度分界点.iter().position(|&x| 简码 < x).unwrap();
                    码长 += 编码信息.简体频率 * 编码长度 as 频率;
                    总组合当量 += 编码信息.简体频率 as 频率 * self.当量信息[简码 as usize];
                    总稳健组合数 += 编码信息.简体指数频率 * (编码长度 - 1) as 频率;
                    总稳健组合当量 += 编码信息.简体指数频率 * self.当量信息[简码 as usize];
                    let mut 剩余编码 = 简码;
                    while 剩余编码 > 0 {
                        let 键 = 剩余编码 % 进制;
                        形码分布[键 as usize] += 编码信息.简体频率;
                        剩余编码 /= 进制;
                    }
                }
            }
            if 编码信息.繁体 {
                繁体总稳健频率 += 编码信息.繁体指数频率;
                if 编码信息.繁体选重 > 0 {
                    繁体选重率 += 编码信息.繁体频率;
                    繁体稳健选重频率 += 编码信息.繁体指数频率;
                    let 分级 = 分级大小
                        .iter()
                        .position(|&x| 编码信息.繁体频序 < x)
                        .unwrap();
                    繁体分级选重数[分级] += 1;
                }
            }
        }

        let (双拼熵, 音码组合当量, _声母分布, 韵母分布) = self.计算音码指标(&音码结果);
        let 字根数 = self
            .决策空间
            .字根
            .iter()
            .filter(|&&x| 解.元素[x] != 元素安排::未选取)
            .count();
        let 字根组数 = self
            .决策空间
            .字根
            .iter()
            .filter(|&&x| {
                !matches!(
                    解.元素[x],
                    元素安排::未选取 | 元素安排::归并(..) | 元素安排::归并韵母 { .. },
                )
            })
            .count();
        形码分布.iter_mut().for_each(|x| *x /= 码长);
        let mut 形码分布偏差 = 0.0;
        let mut 音码分布偏差 = 0.0;
        for (频率, 损失函数) in zip(&形码分布, &self.键位分布信息) {
            let 差距 = 频率 - 损失函数.ideal as 频率;
            if 差距 > 0.0 {
                形码分布偏差 += 损失函数.gt_penalty as 频率 * 差距;
            } else {
                形码分布偏差 -= 损失函数.lt_penalty as 频率 * 差距;
            }
        }
        let 声母总和 = _声母分布.iter().sum::<频率>();
        let 韵母总和 = 韵母分布.iter().sum::<频率>();
        assert!(
            (韵母总和 - 1.0).abs() < 1e-4,
            "韵母分布 {:?} 总和 {}",
            韵母分布,
            韵母总和
        );
        assert!(
            (声母总和 - 1.0).abs() < 1e-4,
            "声母分布 {:?} 总和 {}",
            _声母分布,
            声母总和
        );
        let 数据 = [
            ('u', 15.0, 1.0),
            ('o', 15.0, 1.0),
            ('a', 10.0, 2.0),
            (';', 10.0, 2.0),
            (',', 5.0, 2.0),
            ('.', 5.0, 2.0),
            ('/', 5.0, 2.0),
        ];
        for (按键, 目标, 惩罚率) in 数据 {
            let 键号 = self.棱镜.键转数字[&按键] as usize;
            let 频率 = 韵母分布[键号];
            let 差距 = 频率 - 目标 / 100.0;
            if 差距 > 0.0 {
                音码分布偏差 += 惩罚率 * 差距;
            }
        }
        let 简体稳健选重率 = 简体稳健选重频率 / 简体总稳健频率;
        let 繁体稳健选重率 = 繁体稳健选重频率 / 繁体总稳健频率;
        let 通打平方静态选重率 = 通打平方选重数 as 频率 / 所有汉字数 as 频率;
        let 组合当量 = 总组合当量 / (码长 - 1.0);
        let 稳健组合当量 = 总稳健组合当量 / 总稳健组合数;
        let 拆分难度 = self.打分(解);
        let 韵母难度 = self.韵母打分(解);
        let 指标 = 冰雪清韵指标 {
            拆分难度,
            韵母难度,
            字根数,
            字根组数,
            简体分级选重数,
            简体选重率,
            简体稳健选重率,
            繁体分级选重数,
            繁体选重率,
            繁体稳健选重率,
            通打选重率,
            通打选重数,
            通打最大选重数,
            通打平方选重数,
            组合当量,
            稳健组合当量,
            形码分布,
            韵母分布,
            码长,
            形码分布偏差,
            音码分布偏差,
            音节熵: self.音节熵,
            双拼熵,
            音码组合当量,
            键转数字: self.棱镜.键转数字.clone(),
        };
        let 目标函数值 = 简体稳健选重率 * 100.0
            + 繁体稳健选重率 * 20.0
            + 通打选重率 * 20.0
            + 通打平方静态选重率 * 2.0
            + 稳健组合当量 * 7.0
            + 音码组合当量 * 1.0
            + 形码分布偏差 * 3.0
            + 音码分布偏差 * 0.3
            + (码长 - 2.5) * 1.5
            + 拆分难度 * 0.003
            + 韵母难度 * 0.015
            + (7.0 - 双拼熵) * 0.5;

        (指标, 目标函数值)
    }
}

impl 目标函数 for 冰雪清韵目标函数 {
    type 目标值 = 冰雪清韵指标;
    type 解类型 = 冰雪清韵决策;

    /// 计算各个部分编码的指标，然后将它们合并成一个指标输出
    fn 计算(
        &mut self,
        解: &冰雪清韵决策,
        变化: &Option<冰雪清韵决策变化>,
    ) -> (冰雪清韵指标, f64) {
        let 映射 = 解.线性化(&self.棱镜);
        if let Some(变化) = 变化 {
            if 变化.增加字根.len() > 0 || 变化.减少字根.len() > 0 {
                self.编码器.construct_series(&映射, &mut self.拆分序列, &解);
            }
        } else {
            self.编码器.construct_series(&映射, &mut self.拆分序列, &解);
        };
        self.编码器.dynamic_encode(
            解,
            &映射,
            &self.拆分序列,
            &mut self.编码结果,
            &mut self.音码空间,
        );
        let (指标, 目标函数值) = self.calculate(解, &self.音码空间);
        (指标, 目标函数值.into())
    }
}
